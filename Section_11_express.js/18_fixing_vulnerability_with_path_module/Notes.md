📌 Understanding the path Module in Node.js

    The path module in Node.js provides utilities for working with file and directory paths. Let's break it down with examples and apply it to fix path traversal vulnerabilities in your Express app.

1️⃣ path.join() → Joins Paths Safely

    ✅ Automatically adds / if missing
    ✅ Removes extra /
    ✅ Prevents unnecessary ../ from being misused


    console.log(path.join('/test', '/hello'));  // ➝ "/test/hello"
    console.log(path.join('test', 'hello'));    // ➝ "test/hello"
    console.log(path.join('./test', '///hello//////hi'));  // ➝ "test/hello/hi"


2️⃣ path.normalize() → Cleans Up Paths

    ✅ Removes redundant /
    ✅ Resolves .. when absolute (/.. is removed, ../../.. is preserved if relative)


    console.log(path.normalize('./test///hello//////hi'));  // ➝ "test/hello/hi"
    console.log(path.normalize('/../../../../test'));  // ➝ "/test"
    console.log(path.normalize('../../../../test'));   // ➝ "../../../../../test"


    💡 Key Takeaway:
        `
        If absolute (/..), it removes ...
        If relative (../../), it does not remove ...`


3️⃣ path.resolve() → Gets Absolute Path

    ✅ Converts a relative path to an absolute path.

        console.log(path.resolve('test'));   // ➝ "/Users/xyz/project/test" (CWD + test)
        console.log(path.resolve('/test', 'hi')); // ➝ "/test/hi" (starts from /test)

    💡 Difference Between join() & resolve()

        path.join('a', 'b') ➝ Joins paths without converting to absolute.
        path.resolve('a', 'b') ➝ Returns an absolute path.


4️⃣ path.basename() & path.dirname()

    ✅ Extracts filename or folder path.

        console.log(path.basename('./test/hello/image.png'));  // ➝ "image.png"
        console.log(path.dirname('./test/hello/image.png'));   // ➝ "./test/hello"
        
    💡 Use case: Extract file names when handling file uploads/downloads.

🛡️ Fixing Path Traversal Vulnerability

    📌 Problem in Your Code

        Your directory listing route is vulnerable to path traversal (../):

            app.get('/directory/*', async (req, res) => {
                const dirName = path.join('/', req.params[0]); // ❌ This does NOT prevent traversal
                const fullDirPath = 'path';


✅ Secure Fix Using path.join() + path.normalize()

    We need to ensure that:

    The requested path stays inside the /public directory.
    Path traversal (../) is blocked.

        import path from 'node:path';
        import { readdir } from 'node:fs/promises';

        app.get('/directory/*', async (req, res) => {
            const baseDir = path.join(import.meta.dirname, 'public'); // Allowed root directory
            const requestedPath = req.params[0] || ''; // Get user input path (safe default)
            const fullDirPath = path.normalize(path.join(baseDir, requestedPath)); // Resolve full path

            // 🚫 Prevent Path Traversal (Ensure fullDirPath starts with baseDir)
            if (!fullDirPath.startsWith(baseDir)) {
                return res.status(403).send('🚫 Access Denied: Path Traversal Attempt');
            }

            try {
                const files = await readdir(fullDirPath);
                res.send(files);
            } catch (err) {
                res.status(500).send(`❌ Error: ${err.message}`);
            }
        });



🚨 Never allow direct user input as a file path! Always sanitize & validate.

🚀 Summary

    Method	                Use Case	                    Safe?
    path.join()	            Joins paths safely	            ✅ Yes
    path.normalize()	    Cleans extra / and ..	        ✅ Yes
    path.resolve()	        Gets absolute path	            ❌ No (Can escape root directory)
    path.basename()     	Extracts filename	            ✅ Yes
    path.dirname()	        Extracts directory path	        ✅ Yes







