ğŸ“Œ Understanding the path Module in Node.js

    The path module in Node.js provides utilities for working with file and directory paths. Let's break it down with examples and apply it to fix path traversal vulnerabilities in your Express app.

1ï¸âƒ£ path.join() â†’ Joins Paths Safely

    âœ… Automatically adds / if missing
    âœ… Removes extra /
    âœ… Prevents unnecessary ../ from being misused


    console.log(path.join('/test', '/hello'));  // â "/test/hello"
    console.log(path.join('test', 'hello'));    // â "test/hello"
    console.log(path.join('./test', '///hello//////hi'));  // â "test/hello/hi"


2ï¸âƒ£ path.normalize() â†’ Cleans Up Paths

    âœ… Removes redundant /
    âœ… Resolves .. when absolute (/.. is removed, ../../.. is preserved if relative)


    console.log(path.normalize('./test///hello//////hi'));  // â "test/hello/hi"
    console.log(path.normalize('/../../../../test'));  // â "/test"
    console.log(path.normalize('../../../../test'));   // â "../../../../../test"


    ğŸ’¡ Key Takeaway:
        `
        If absolute (/..), it removes ...
        If relative (../../), it does not remove ...`


3ï¸âƒ£ path.resolve() â†’ Gets Absolute Path

    âœ… Converts a relative path to an absolute path.

        console.log(path.resolve('test'));   // â "/Users/xyz/project/test" (CWD + test)
        console.log(path.resolve('/test', 'hi')); // â "/test/hi" (starts from /test)

    ğŸ’¡ Difference Between join() & resolve()

        path.join('a', 'b') â Joins paths without converting to absolute.
        path.resolve('a', 'b') â Returns an absolute path.


4ï¸âƒ£ path.basename() & path.dirname()

    âœ… Extracts filename or folder path.

        console.log(path.basename('./test/hello/image.png'));  // â "image.png"
        console.log(path.dirname('./test/hello/image.png'));   // â "./test/hello"
        
    ğŸ’¡ Use case: Extract file names when handling file uploads/downloads.

ğŸ›¡ï¸ Fixing Path Traversal Vulnerability

    ğŸ“Œ Problem in Your Code

        Your directory listing route is vulnerable to path traversal (../):

            app.get('/directory/*', async (req, res) => {
                const dirName = path.join('/', req.params[0]); // âŒ This does NOT prevent traversal
                const fullDirPath = 'path';


âœ… Secure Fix Using path.join() + path.normalize()

    We need to ensure that:

    The requested path stays inside the /public directory.
    Path traversal (../) is blocked.

        import path from 'node:path';
        import { readdir } from 'node:fs/promises';

        app.get('/directory/*', async (req, res) => {
            const baseDir = path.join(import.meta.dirname, 'public'); // Allowed root directory
            const requestedPath = req.params[0] || ''; // Get user input path (safe default)
            const fullDirPath = path.normalize(path.join(baseDir, requestedPath)); // Resolve full path

            // ğŸš« Prevent Path Traversal (Ensure fullDirPath starts with baseDir)
            if (!fullDirPath.startsWith(baseDir)) {
                return res.status(403).send('ğŸš« Access Denied: Path Traversal Attempt');
            }

            try {
                const files = await readdir(fullDirPath);
                res.send(files);
            } catch (err) {
                res.status(500).send(`âŒ Error: ${err.message}`);
            }
        });



ğŸš¨ Never allow direct user input as a file path! Always sanitize & validate.

ğŸš€ Summary

    Method	                Use Case	                    Safe?
    path.join()	            Joins paths safely	            âœ… Yes
    path.normalize()	    Cleans extra / and ..	        âœ… Yes
    path.resolve()	        Gets absolute path	            âŒ No (Can escape root directory)
    path.basename()     	Extracts filename	            âœ… Yes
    path.dirname()	        Extracts directory path	        âœ… Yes







